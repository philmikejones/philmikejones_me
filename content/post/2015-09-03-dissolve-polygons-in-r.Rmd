---
title: Dissolve polygons in R
date: 2015-09-03
author: philmikejones
categories:
  - GIS
  - rstats
tags:
  - dissolve
  - gis
  - polygon
  - r
---

Dissolving polygons is another fairly elementary GIS task that I need to perform regularly.
With R this is can be a bit involved, but once done is fully reproducible and the code can be re-used.
This post is essentially a companion piece to [Clipping polygons in R](https://philmikejones.me/post/2015-09-01-clipping-polygons-in-r/); I wrote both because I often forget how to complete these tasks in R.


## Update 2018-02-07 - using `sf`

In the last couple of years or so the [`sf` package](https://cran.r-project.org/package=sf) has replaced most of the functionality of `rgdal` and `rgeos`.
It has a number of advantages over these older packages:

- It doesn't use the [S4 object system](http://adv-r.had.co.nz/S4.html), which means no more `@` slots.
- `sf` functions are generally faster than `rgdal` counterparts.
- `sf` data frames conform to [tidy data](http://r4ds.had.co.nz/tidy-data.html) principles and there are `dplyr` verbs to manipulate them.

Overall, then, `sf` is much more convenient and efficient to work with, so I've updated my tutoral to use this new package.
The older `rgdal` based tutorial will of course still work.

### Getting started

First, install and load `sf` for loading the shapefiles, `dplyr` for manipulating the data, and `ggplot2` for plotting the maps.
You could also load the complete tidyverse but this currently causes problems for loading the development version of `ggplot2` so use caution.
Hopefully this issue will be resolved with an update to `ggplot2` in the near future.

```{r package-load, eval=FALSE}
if (!require("dplyr")) {
  install.packages("dplyr")
  library("dplyr")
}

if (!require("sf")) {
  install.packages("sf")
  library("sf")
}

# currently (early 2018) you need the development version of ggplot2
# to work with sf
if (!require("devtools")) {
  install.packages("devtools")
}
devtools::install_github("tidyverse/ggplot2")
library("ggplot2")
```

Next we need to download the files we'll be using.
I've used regions as a simple example.
We'll download the files to a temporary directory and get started.

```{r download-files, eval=FALSE}
tmp_dir <- tempdir()
tmp     <- tempfile(tmpdir = tmp_dir, fileext = ".zip")

download.file(
  "http://census.edina.ac.uk/ukborders/easy_download/prebuilt/shape/England_gor_2011.zip",
  destfile = tmp
)
unzip(tmp, exdir = tmp_dir)
```

And now load the shapefile we just extracted and plot it to ensure it's worked:

```{r load-shapefiles, eval=FALSE}
regions <- read_sf(tmp_dir, "england_gor_2011")
ggplot(regions) + geom_sf()
```

```{r insert-regions-plot, echo=FALSE}
blogdown::shortcode_html(
  "figure",
  src = "../../img/regions.png",
  alt = "English regions",
  caption = "English regions")
```

Now lets have a look at the data (without the geometry):

```{r inspect-regions-data, eval=FALSE}
head(st_set_geometry(regions, NULL))
```

```{r inspect-regions-data-saved, echo=FALSE}
regions_data <- readRDS("../../static/data/regions_data.RDS")
head(regions_data)
```

Dissolves with `sf()` do not save the data frame (other than the geometry column) by default without specifying how to aggregate the data.
Using area as an example:

```{r create-regions_area-data, echo=FALSE, eval=FALSE}
regions$area <- st_area(regions)
regions_area <- regions
regions_area <- st_set_geometry(regions_area, NULL)
saveRDS(regions_area, "static/data/regions_area.RDS")
```

```{r calc-area, eval=FALSE}
regions$area <- st_area(regions)
head(st_set_geometry(regions, NULL))
```

```{r load-regions_area-data, echo=FALSE}
regions_area <- readRDS("../../static/data/regions_area.RDS")
head(regions_area)
```

Now we have something some data that's meaningful to group, we can just use `summarise()` to group the data and perform the dissolve:

```{r dissolve-preserve, eval=FALSE}
england <- 
  regions %>% 
  summarise(area = sum(area))
```

```{r plot-dissolve-preserve, eval=FALSE}
ggplot(england) + geom_sf()
```

```{r save-dissolve-preserve-plot, eval=FALSE, echo=FALSE}
ggsave(
  "static/img/dissolve-preserve-data.png",
  width = 254, units = "mm", dpi = 72
)
```

```{r plot-saved-dissolve-preserve, echo=FALSE}
blogdown::shortcode_html(
  "figure",
  src = "../../img/dissolve-preserve-data.png",
  alt = "Dissolve polygons",
  caption = "Dissolve polygons")
```

If you don't have or want data to save the dissolve just create a column to `group_by()` so that the features (rows) that are to be grouped together are given the same data:

```{r dissolve-group-country, eval=FALSE}
england <- 
  regions %>% 
  mutate(country = "england") %>% 
  group_by(country) %>% 
  summarise()
```


## Original `rgdal` instructions

### Getting started

Let's gather together everything we need to complete this example. We need a shapefile of small geographies to &#8216;dissolve', a lookup table to tell us which polygons dissolve into which, and we need a couple of R spatial packages to run everything. Let's get started.

<pre># The default behaviour of this script is to create a folder called 'dissolve-example'
# and download and run everything from here.
# You can change this by modifying the next two lines
dir.create("dissolve-example")
setwd("dissolve-example")

# Load a few packages. dplyr makes merges easier
require("rgdal")
require("rgeos")
require("dplyr")

# Set up shapefile to dissolve. I'm using English regions
download.file("http://census.edina.ac.uk/ukborders/easy_download/prebuilt/shape/England_gor_2011.zip",
              destfile = "lad-region-lookup.zip")
unzip("lad-region-lookup.zip", exdir = ".")
region &lt;- readOGR(".", "England_gor_2011")

# Check the shapefile has loaded correctly
plot(region)

# We're going to dissolve all regions in to one country (England!)
# For this we'll create a lookup table and merge with the spatial data
# Hopefully for your 'real' data you have a lookup table of all polygons and
# their larger geography already!
lu &lt;- data.frame()
lu &lt;- rbind(lu, region@data)
lu$CODE &lt;- as.character(lu$CODE)
lu$NAME &lt;- as.character(lu$NAME)
lu$country &lt;- NA
lu$country &lt;- "England"</pre>

## Merge

We now need to merge the lookup table into our spatial object data frame. We should end up with one row per zone to dissolve, each with a reference for the relevant larger geography. I think the trick is to make sure the row names match exactly, and if you can match the polygon IDs as well with <tt>spChFIDs()</tt>.

<pre># Merge lu (LookUp) into polygons,
region@data$CODE &lt;- as.character(region@data$CODE)
region@data &lt;- full_join(region@data, lu, by = "CODE")

# Tidy merged data
region@data &lt;- select(region@data, -NAME.x)
colnames(region@data) &lt;- c("code", "name", "country")

# Ensure shapefile row.names and polygon IDs are sensible
row.names(region) &lt;- row.names(region@data)
region &lt;- spChFIDs(region, row.names(region))</pre>

## Dissolve

Now we can do the dissolve. I use <tt>gUnaryUnion</tt> (and indeed I think <tt>unionSpatialPolygons</tt> in the maptools package uses this by default).

<pre># Now the dissolve
region &lt;- gUnaryUnion(region, id = region@data$country)</pre>

If you want to just plot this using base plot you can stop there. If you want to do anything with the data or plot using ggplot you need to recreate the data frame.

<pre># If you want to recreate an object with a data frame
# make sure row names match
row.names(region) &lt;- as.character(1:length(region))

# Extract the data you want (the larger geography)
lu &lt;- unique(lu$country)
lu &lt;- as.data.frame(lu)
colnames(lu) &lt;- "country"  # your data will probably have more than 1 row!

# And add the data back in
region &lt;- SpatialPolygonsDataFrame(region, lu)

# Check it's all worked
plot(region)</pre>

And your data frame should look like this:

<pre>region@data
##   country
## 1 England</pre>
