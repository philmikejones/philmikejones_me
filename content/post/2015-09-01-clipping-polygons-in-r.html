---
title: Clipping polygons in R
date: 2015-09-01
author: philmikejones
categories:
  - GIS
  - rstats
tags:
  - clip
  - gis
  - polygon
  - r
---



<p>Clipping polygons is a basic GIS task. It involves removing unneeded polygons outside of an area of interest. For example, you might want to study all local authorities (LADs) in the Yorkshire and the Humber region but can only obtain shapefiles that contain all the LADs in the UK. Removing the LADs outside of Yorkshire and the Humber could be achieved by ‘clipping’ the shapefile of LADs, using the extent of the larger region as a template. In R this takes a bit of work, but is quite possible with a few lines of code and has the advantage of being fully <a href="https://en.wikipedia.org/wiki/Reproducibility">reproducible</a>.</p>
<div id="update-february-2018" class="section level2">
<h2>Update February 2018</h2>
<p>In the last couple of years the <a href="https://cran.r-project.org/package=sf"><code>sf</code> package</a> has been released and has been steadily maturing, to the point that it’s now my preferred package for GIS in R, replacing <code>rgdal</code> and <code>rgeos</code>. I also recommend it for anyone coming to GIS in R for the first time, as it’s faster and more efficient than the packages it replaces. I’ve updated this tutorial to show how to clip with <code>sf</code>.</p>
<p>First, install and load <code>sf</code> for loading the shapefiles, <code>dplyr</code> for manipulating the data, and <code>ggplot2</code> for plotting the maps. You could also load the complete tidyverse but this currently causes problems for loading the development version of <code>ggplot2</code> so use caution. Hopefully this issue will be resolved with an update to <code>ggplot2</code> in the near future.</p>
<pre class="r"><code>if (!require(&quot;dplyr&quot;)) {
  install.packages(&quot;dplyr&quot;)
  library(&quot;dplyr&quot;)
}

if (!require(&quot;sf&quot;)) {
  install.packages(&quot;sf&quot;)
  library(&quot;sf&quot;)
}

# currently (early 2018) you need the development version of ggplot2
# to work with sf
if (!require(&quot;devtools&quot;)) {
  install.packages(&quot;devtools&quot;)
}
devtools::install_github(&quot;tidyverse/ggplot2&quot;)
library(&quot;ggplot2&quot;)</code></pre>
<p>Then download and unzip our test data (shapefiles of English regions and local authorities):</p>
<pre class="r"><code>tmp_dir &lt;- tempdir()

# a region shapefile for England ~6MB
tmp_reg &lt;- tempfile(tmpdir = tmp_dir, fileext = &quot;.zip&quot;)
download.file(
  &quot;https://borders.ukdataservice.ac.uk/ukborders/easy_download/prebuilt/shape/England_gor_2011.zip&quot;,
  destfile = tmp_reg
)
unzip(tmp_reg, exdir = tmp_dir)

# local authorities for England ~ 
tmp_lad &lt;- tempfile(tmpdir = tmp_dir, fileext = &quot;.zip&quot;)
download.file(
  &quot;https://borders.ukdataservice.ac.uk/ukborders/easy_download/prebuilt/shape/England_lad_2011.zip&quot;,
  destfile = tmp_lad
)
unzip(tmp_lad, exdir = tmp_dir)</code></pre>
<p>Now load these files ready for clipping:</p>
<pre class="r"><code>reg &lt;- read_sf(  # regions
  dsn = tmp_dir,
  layer = &quot;england_gor_2011&quot;
)

lad &lt;- read_sf(  # Local Authority District
  dsn = tmp_dir,
  layer = &quot;england_lad_2011&quot;
)</code></pre>
<p>Let’s check these have loaded correctly with a plot:</p>
<pre class="r"><code>ggplot(reg) + geom_sf()</code></pre>
{{< figure src="../../img/regions.png" alt="English regions" caption="English regions" >}}
<pre class="r"><code>ggplot(lad) + geom_sf()</code></pre>
{{< figure src="../../img/lads.png" alt="English local authority districts" caption="English local authority districts" >}}
<p>To clip the LADs to a region, use <code>sf::st_contains()</code> with <code>sparse = FALSE</code> argument:</p>
<pre class="r"><code>yh &lt;- 
  reg %&gt;% 
  filter(name == &quot;Yorkshire and The Humber&quot;)

yh_lads &lt;- 
  lad %&gt;% 
  filter(st_contains(yh, ., sparse = FALSE))</code></pre>
<p>And a plot to check the clip succeeded:</p>
<pre class="r"><code>ggplot(yh_lads) + geom_sf()</code></pre>
{{< figure src="../../img/yh_lads.png" alt="LADs in Yorkshire and The Humber" caption="LADs in Yorkshire and The Humber" >}}
<p>We can also check the data are still included in the <code>yh_lads</code> object (without the geometry):</p>
<pre class="r"><code>head(yh_lads)</code></pre>
<pre><code>##        code        name altname     label
## 1 E07000164   Hambleton    &lt;NA&gt; E07000164
## 2 E07000169       Selby    &lt;NA&gt; E07000169
## 3 E08000017   Doncaster    &lt;NA&gt; E08000017
## 4 E07000168 Scarborough    &lt;NA&gt; E07000168
## 5 E08000032    Bradford    &lt;NA&gt; E08000032
## 6 E07000165   Harrogate    &lt;NA&gt; E07000165</code></pre>
</div>
<div id="original-post" class="section level2">
<h2>Original post</h2>
<div id="getting-started" class="section level3">
<h3>Getting started</h3>
<p>Let’s start by obtaining administrative boundary shapefiles in England, loading necessary packages, and quickly checking the shapefiles are plotting correctly. We will need both regions and LADs. I’m using the freely-available boundaries from the <a href="http://census.ukdataservice.ac.uk/">UK Data Service</a>:</p>
<pre># The default behaviour of this script is to create a folder called 'clip-example'
# and download and run everything from here.
# You can change this by modifying the next two lines
dir.create("clip-example")
setwd("clip-example")

# download and unzip UK administrative boundary shapefiles
download.file("https://census.edina.ac.uk/ukborders/easy_download/prebuilt/shape/England_gor_2011.zip",
              destfile = "gor.zip")  # ~6.4MB
download.file("https://census.edina.ac.uk/ukborders/easy_download/prebuilt/shape/England_lad_2011.zip",
              destfile = "lad.zip")  # ~25MB
unzip("gor.zip", exdir = ".") # '.' just means current directory
unzip("lad.zip", exdir = ".")

# I recommend loading the shapefiles with readOGR() in the rgdal package
# install.packages("rgdal") # uncomment and run if not already installed
# install.packages("rgeos") # as above

# If you run in to trouble installing rgdal and rgeos on Linux (Ubuntu) see:
# https://philmikejones.me/post/2014-07-14-installing-rgdal-in-r-on-linux/

require("rgdal")
require("rgeos")

regions &lt;- readOGR(".", "england_gor_2011")
plot(regions) # worth a quick check everything looks like it should!

lads &lt;- readOGR(".", "england_lad_2011")
plot(lads)</pre>
<p>So now we have everything we need to begin: a shapefile of English regions, and a shapefile of English LADs.</p>
</div>
<div id="extract-yorkshire-and-the-humber" class="section level3">
<h3>Extract Yorkshire and the Humber</h3>
<p>You’ve hopefully seen from your test plot that the shapefiles are plotting all boundaries in England, so first let’s remove all but Yorkshire and the Humber from the regions shapefile. We can do this by looking for the names of the regions in the shapefiles attributes file and using standard subsetting syntax. If you’ve used other GIS software before hopefully this idea will be familiar to you, but if not, don’t worry!</p>
<pre>regions &lt;- regions[regions@data$name == "Yorkshire and The Humber", ]
# Another plot confirms just the Yorkshire and The Humber region is left
plot(regions)</pre>
</div>
<div id="clip-the-lads" class="section level3">
<h3>Clip the LADs</h3>
<p>The <tt>regions</tt> object now just contains Yorkshire and The Humber, so we can use this as our bounds to extract LADs:</p>
<pre>yh_lads &lt;- gIntersection(regions, lads, byid = TRUE, drop_lower_td = TRUE)
plot(yh_lads)</pre>
<p>Easy, but we’re not finished yet. The clipped polygons no longer contain a data frame because the <tt>gIntersection</tt> doesn’t (and can’t) know which data frame items to save in to the new object. This means we must add them back in manually, but even this is relatively straight-forward.</p>
</div>
<div id="recreate-the-data-frame" class="section level3">
<h3>Recreate the data frame</h3>
<p>The row names for the clipped polygons are a concatenation of the regions row name and the LAD row names. These are in the form <tt>x yyyy</tt> where <tt>x</tt> is the region row name (in our case always 5, because Yorkshire and The Humber was row 5) and <tt>yyyy</tt> is the LAD row name. This can be confirmed with:</p>
<pre>row.names(yh_lads)
## [1] "5 2"   "5 8"   "5 9"   "5 37"  "5 39"  "5 43"  "5 105" "5 124" "5 162" "5 165"
## [11] "5 175" "5 204" "5 207" "5 214" "5 225" "5 245" "5 248" "5 251" "5 254" "5 297"
## [21] "5 320"</pre>
<p>So that we can create a data frame based on the LAD data frame, we must first ensure our row names match the LAD row names so they can be merged across. I do this by removing the “<tt>5 </tt>” with <tt>gsub()</tt>:</p>
<pre>row.names(yh_lads) &lt;- gsub("5 ", "", row.names(yh_lads))
# Confirm it worked
row.names(yh_lads)
##  [1] "2"   "8"   "9"   "37"  "39"  "43"  "105" "124" "162" "165" "175" "204" "207"
## [14] "214" "225" "245" "248" "251" "254" "297" "320"</pre>
<p>So far, so good. Now we create a variable – “<tt>keep</tt>” – that contains the row names that we want to keep from the LADs data frame.</p>
<pre>keep &lt;- row.names(yh_lads)</pre>
<p>For the sake of simplicity I also change the polygon IDs so they are consistent with their respective row names. This step is probably optional, but I prefer to ensure they match so I have a consistent set of IDs to work with later on. If you choose not to do this I don’t think you’ll run into any problems but <a href="http://www.urbandictionary.com/define.php?term=ymmv">YMMV</a>.</p>
<pre>yh_lads &lt;- spChFIDs(yh_lads, keep)</pre>
<p>Now we create a copy of the LAD dataframe and filter it so that it only contains the rows we want to keep, using row names to perform the match:</p>
<pre>yh_data &lt;- as.data.frame(lads@data[keep, ])</pre>
<p>Finally we create a <tt>SpatialPolygonsDataFrame</tt> object with our clipped polygons and our subsetted data frame:</p>
<pre>yh_lads &lt;- SpatialPolygonsDataFrame(yh_lads, yh_data)</pre>
<p>All being well, you should be able to plot the result with:</p>
<pre>plot(yh_lads)</pre>
<p>And your <tt>yh_lads</tt> object should contain attribute data, which can be viewed with:</p>
<pre>yh_lads@data
##           CODE                        NAME ALTNAME
##  2   E07000164                   Hambleton    
##  8   E07000169                       Selby    
##  9   E08000017                   Doncaster    
##  37  E07000168                 Scarborough    
##  39  E08000032                    Bradford    
##  43  E07000165                   Harrogate    
##  105 E07000167                     Ryedale    
##  124 E07000166               Richmondshire    
##  162 E06000012     North East Lincolnshire    
##  165 E08000035                       Leeds    
##  175 E07000163                      Craven    
##  204 E08000033                  Calderdale    
##  207 E06000013          North Lincolnshire    
##  214 E08000019                   Sheffield    
##  225 E06000010 Kingston upon Hull, City of    
##  245 E06000011    East Riding of Yorkshire    
##  248 E06000014                        York    
##  251 E08000036                   Wakefield    
##  254 E08000034                    Kirklees    
##  297 E08000016                    Barnsley    
##  320 E08000018                   Rotherham    

# If further confirmation is required:
class(yh_lads)
##  [1] "SpatialPolygonsDataFrame"
##  attr(,"package")
##  [1] "sp"</pre>
<p>Congratulations, a fully reproducible polygon clip!</p>
</div>
</div>
