---
title: "Test your data"
author: "Phil Mike Jones"
date: 2019-03-22
categories: "tutorials"
tags: ["r", "rstats", "test", "unit test", "testthat"]
---

```{r library, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE, eval=TRUE}
library("testthat")
```

I've written and spoken before about how important it is to [test your functions and data analysis scripts](blog/unit-testing-in-r/).
In this tutorial I revisit these ideas and demonstrate how and why to test your data.
I use `testthat` in `R` although the ideas are language--agnostic.
I decided to revisit these ideas and write this tutorial based on my recent experience of calculating the number of units of alcohol the panel members in the [NCDS and BCS70 birth cohorts](https://cls.ucl.ac.uk/cls-studies/) drank at different time points.
I initially thought this would be a straightforward mathematical calculation but this turned out to be vastly more complicated than I thought (it always does!).
My tests of the data identified the problem (something I would likely have missed without them) and confirmed when I had solved it.

<!--more-->

I am currently using the NCDS and BCS70 birth cohort data sets to model alcohol consumption at different time points.
Panel members were asked questions about the type and quantity of drinks they consumed in the past seven days, and we decided to convert these into just units of alcohol consumed to simplify the modelling.
For example, at most time points cohort members were asked how many pints or glasses of beer, wine, and spirits they had consumed in the past seven days.
One pint of beer does not contain the same amount of alcohol as one glass of wine; if we were to include these items individually this makes the model quite difficult to interpret.
By calculating units of alcohol we only need to include one term in the model making it easier to produce and more intuitive to interpret.

For this example I'm going to take an extract from the BCS70 cohort in 1986 when they were aged 16, but the other time points and cohort raised very similar issues because they were recorded in very similar ways.
I obviously can't include actual BCS70 data as it is restricted (but if you're a UK academic researcher you can download the [BCS70 sixteen--year follow--up (1986)](https://beta.ukdataservice.ac.uk/datacatalogue/studies/study?id=3535) yourself).
I've taken a sample of 100 respondents and removed their given IDs and replaced these with just a unique integer.
In all other respects I've constructed the example data to be as close to the original data as possible, including the number of completed/missing responses.
The issues I raise with this example data set are very real based on the actual issues I encountered (and which are themselves pretty typical of the kind of issues of social science research).
You can [download my example data](https://philmikejones.me/tutorials/2019-03-22-test-your-data/bcs70.csv) or load it directly into `R`.

As with any script, first let's load the packages we need:

```{r packages, message=FALSE}
# if necessary run:
# install.packages(c("readr", "dplyr", "testthat", "usethis"))

library("readr")
library("dplyr")
library("usethis")
library("testthat")
```

Now download the example data we'll use:

```{r download-data}
url = "~/gits/philmikejones_me/static/tutorials/2019-03-22-test-your-data/bcs70.csv"
bcs70 = read_csv(url)
```

Let's take a look at the top and bottom 10 cases:

```{r data}
head(bcs70)
tail(bcs70)
```

Like all social science data it is a bit messy.
We can see there are a lot of completely missing cases (`NA`) so these respondents exist at some point in the BCS70 but were not asked the alcohol questions (or any questions) in 1986.
Those with answers look like they have a value in each question (even if it's `0.0`).
So let's get to it.

My approach here is to calculate the number of units of each drink type consumed and create a new variable for each.
So for `beer` I will calculate `beer_units`, `cider` I will calculate `cider_units`, and so on.
I will therefore be using `mutate()` in the `dplyr()` package for these calculations so that existing variables are not removed.

```{r calculate-units}
bcs70 =
  bcs70 %>%
  mutate(
    beer_units = beer * 2.3,
    cider_units = cider * 2.6,
    sherry_units = sherry * 1.8,
    wine_units = wine * 1.8,
    shandy_units = shandy * 2.3 / 2,
    spirits_units = spirits * 1.0
  )

bcs70
```

After I've calculated the units for each individual drink I'll first try simply adding them up to arrive at the number of units consumed in the past seven days:

```{r total-units}
bcs70 =
  bcs70 %>%
  mutate(
    total_units =
      beer_units + cider_units + sherry_units + wine_units +
      shandy_units + spirits_units
  )

bcs70
```

To test to see if this worked I create a test suite.
The easiest way to do this is with the `usethis` package:

```{r setup-tests, eval=FALSE}
use_test("test-bcs70")
```

This creates the necessary `tests/` directories and sets up a test file.
First set up a context and load the necessary libraries, and as our first test I want to ensure the calculated `_units` variables are numeric (specifically double):

```{r test-type}
context("Test bcs70")

test_that("Calculated units are numeric", {
  expect_type(bcs70$beer_units, "double")
  expect_type(bcs70$cider_units, "double")
  expect_type(bcs70$sherry_units, "double")
  expect_type(bcs70$wine_units, "double")
  expect_type(bcs70$shandy_units, "double")
  expect_type(bcs70$spirits_units, "double")
  expect_type(bcs70$total_units, "double")
})
```

Next I want to test that the number of units calculated are plausible amounts.
The minimum number of units should be `0.0`; it's not possible to consume a negative number of units.

```{r test-min, eval=FALSE}
test_that("Calculated minimum units are 0.0", {
  expect_gte(min(bcs70$beer_units), 0.0)
  expect_gte(min(bcs70$cider_units), 0.0)
  expect_gte(min(bcs70$sherry_units), 0.0)
  expect_gte(min(bcs70$wine_units), 0.0)
  expect_gte(min(bcs70$shandy_units), 0.0)
  expect_gte(min(bcs70$spirits_units), 0.0)
  expect_gte(min(bcs70$total_units), 0.0)
})
```

If you run the code above, the tests will fail.
This is because the `min` of a vector with an `NA` in is `NA`: i.e. the `min` of `bcs70$beer` is `NA` because there's an `NA` in that vector:

```{r min-na}
is.na(min(bcs70$beer))
```

This is something I forget all the time:

<blockquote class="twitter-tweet" data-cards="hidden" data-lang="en"><p lang="en" dir="ltr">If I had a quid for every time I forgot that NA + 0.0 is NOT 0.0 I&#39;d still be as forgetful but at least I&#39;d be richer <a href="https://twitter.com/hashtag/RStats?src=hash&amp;ref_src=twsrc%5Etfw">#RStats</a> <a href="https://t.co/iaUBCd87Rk">pic.twitter.com/iaUBCd87Rk</a></p>&mdash; üá™üá∫üåç Phil (@philmikejones) <a href="https://twitter.com/philmikejones/status/1107958263247720448?ref_src=twsrc%5Etfw">March 19, 2019</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

So we must modify our tests to exclude the NAs with [`na.rm = TRUE`](https://www.rdocumentation.org/packages/base/versions/3.5.3/topics/Extremes):

```{r test-min-na}
test_that("Calculated minimum units are 0.0", {
  expect_gte(min(bcs70$beer_units, na.rm = TRUE), 0.0)
  expect_gte(min(bcs70$cider_units, na.rm = TRUE), 0.0)
  expect_gte(min(bcs70$sherry_units, na.rm = TRUE), 0.0)
  expect_gte(min(bcs70$wine_units, na.rm = TRUE), 0.0)
  expect_gte(min(bcs70$shandy_units, na.rm = TRUE), 0.0)
  expect_gte(min(bcs70$spirits_units, na.rm = TRUE), 0.0)
  expect_gte(min(bcs70$total_units, na.rm = TRUE), 0.0)
})

message("Tests pass")
```

So far, so good.
(You don't need to manually add the `message()` line under normal circumstances as you get feedback from `testthat` in interactive mode, but it's useful here to see if the tests are successful).

Now I want to test to see if the maximum number of units is sensible.
I didn't know in advance what the maximum number of drinks should be, but I worked out that 180 was a sensible maximum for the individual drinks (and therefore `r 180 * 6` for the total); this is where your domain knowledge comes in:

```{r test-max}
test_that("Calculated maximum units are 180.0/1080.0", {
  expect_lte(max(bcs70$beer_units, na.rm = TRUE), 180.0)
  expect_lte(max(bcs70$cider_units, na.rm = TRUE), 180.0)
  expect_lte(max(bcs70$sherry_units, na.rm = TRUE), 180.0)
  expect_lte(max(bcs70$wine_units, na.rm = TRUE), 180.0)
  expect_lte(max(bcs70$shandy_units, na.rm = TRUE), 180.0)
  expect_lte(max(bcs70$spirits_units, na.rm = TRUE), 180.0)
  expect_lte(max(bcs70$total_units, na.rm = TRUE), 1080.0)
})

message("Tests pass")
```
